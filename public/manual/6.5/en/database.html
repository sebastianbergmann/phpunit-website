<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8">
  <title>PHPUnit Manual &#8211; Chapter 8. Database Testing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="canonical" href="https://phpunit.de/manual/current/en/database.html">
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/highlight.css" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700%7CSource+Code+Pro:400,700' rel='stylesheet' type='text/css'>
  <!--[if lt IE 9]><script src="js/html5shiv.min.js"></script><![endif]-->
 </head>
 <body>
  <nav class="navbar navbar-default" role="navigation">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav navbar-left">
            <li>
                <a href="https://phpunit.de/documentation.html">This documentation is outdated. Please follow this link to learn about the new documentation.</a>
            </li>
        </ul>
    </div>
  </nav>
  <div class="container-fluid">
   <div class="row">
    <div class="col-md-4 col-lg-3">
     <div class="well well-sm sidebar-nav">
<dl class="toc nav hidden-print"><dt><span class="chapter"><a href="installation.html">1. Installing PHPUnit</a></span></dt><dd><dl><dt><span class="section"><a href="installation.html#installation.requirements">Requirements</a></span></dt><dt><span class="section"><a href="installation.html#installation.phar">PHP Archive (PHAR)</a></span></dt><dd><dl><dt><span class="section"><a href="installation.html#installation.phar.windows">Windows</a></span></dt><dt><span class="section"><a href="installation.html#installation.phar.verification">Verifying PHPUnit PHAR Releases</a></span></dt></dl></dd><dt><span class="section"><a href="installation.html#installation.composer">Composer</a></span></dt><dt><span class="section"><a href="installation.html#installation.optional-packages">Optional packages</a></span></dt></dl></dd><dt><span class="chapter"><a href="writing-tests-for-phpunit.html">2. Writing Tests for PHPUnit</a></span></dt><dd><dl><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.test-dependencies">Test Dependencies</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.data-providers">Data Providers</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.exceptions">Testing Exceptions</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.errors">Testing PHP Errors</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.output">Testing Output</a></span></dt><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.error-output">Error output</a></span></dt><dd><dl><dt><span class="section"><a href="writing-tests-for-phpunit.html#writing-tests-for-phpunit.error-output.edge-cases">Edge cases</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="textui.html">3. The Command-Line Test Runner</a></span></dt><dd><dl><dt><span class="section"><a href="textui.html#textui.clioptions">Command-Line Options</a></span></dt></dl></dd><dt><span class="chapter"><a href="fixtures.html">4. Fixtures</a></span></dt><dd><dl><dt><span class="section"><a href="fixtures.html#fixtures.more-setup-than-teardown">More setUp() than tearDown()</a></span></dt><dt><span class="section"><a href="fixtures.html#fixtures.variations">Variations</a></span></dt><dt><span class="section"><a href="fixtures.html#fixtures.sharing-fixture">Sharing Fixture</a></span></dt><dt><span class="section"><a href="fixtures.html#fixtures.global-state">Global State</a></span></dt></dl></dd><dt><span class="chapter"><a href="organizing-tests.html">5. Organizing Tests</a></span></dt><dd><dl><dt><span class="section"><a href="organizing-tests.html#organizing-tests.filesystem">Composing a Test Suite Using the Filesystem</a></span></dt><dt><span class="section"><a href="organizing-tests.html#organizing-tests.xml-configuration">Composing a Test Suite Using XML Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="risky-tests.html">6. Risky Tests</a></span></dt><dd><dl><dt><span class="section"><a href="risky-tests.html#risky-tests.useless-tests">Useless Tests</a></span></dt><dt><span class="section"><a href="risky-tests.html#risky-tests.unintentionally-covered-code">Unintentionally Covered Code</a></span></dt><dt><span class="section"><a href="risky-tests.html#risky-tests.output-during-test-execution">Output During Test Execution</a></span></dt><dt><span class="section"><a href="risky-tests.html#risky-tests.test-execution-timeout">Test Execution Timeout</a></span></dt><dt><span class="section"><a href="risky-tests.html#risky-tests.global-state-manipulation">Global State Manipulation</a></span></dt></dl></dd><dt><span class="chapter"><a href="incomplete-and-skipped-tests.html">7. Incomplete and Skipped Tests</a></span></dt><dd><dl><dt><span class="section"><a href="incomplete-and-skipped-tests.html#incomplete-and-skipped-tests.incomplete-tests">Incomplete Tests</a></span></dt><dt><span class="section"><a href="incomplete-and-skipped-tests.html#incomplete-and-skipped-tests.skipping-tests">Skipping Tests</a></span></dt><dt><span class="section"><a href="incomplete-and-skipped-tests.html#incomplete-and-skipped-tests.skipping-tests-using-requires">Skipping Tests using @requires</a></span></dt></dl></dd><dt><span class="chapter"><a href="database.html" class="active">8. Database Testing</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.supported-vendors-for-database-testing">Supported Vendors for Database Testing</a></span></dt><dt><span class="section"><a href="database.html#database.difficulties-in-database-testing">Difficulties in Database Testing</a></span></dt><dt><span class="section"><a href="database.html#database.the-four-stages-of-a-database-test">The four stages of a database test</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.clean-up-database">1. Clean-Up Database</a></span></dt><dt><span class="section"><a href="database.html#database.set-up-fixture">2. Set up fixture</a></span></dt><dt><span class="section"><a href="database.html#database.run-test-verify-outcome-and-teardown">3–5. Run Test, Verify outcome and Teardown</a></span></dt></dl></dd><dt><span class="section"><a href="database.html#database.configuration-of-a-phpunit-database-testcase">Configuration of a PHPUnit Database TestCase</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.implementing-getconnection">Implementing getConnection()</a></span></dt><dt><span class="section"><a href="database.html#database.implementing-getdataset">Implementing getDataSet()</a></span></dt><dt><span class="section"><a href="database.html#database.what-about-the-database-schema-ddl">What about the Database Schema (DDL)?</a></span></dt><dt><span class="section"><a href="database.html#database.tip-use-your-own-abstract-database-testcase">Tip: Use your own Abstract Database TestCase</a></span></dt></dl></dd><dt><span class="section"><a href="database.html#database.understanding-datasets-and-datatables">Understanding DataSets and DataTables</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.available-implementations">Available Implementations</a></span></dt><dt><span class="section"><a href="database.html#database.beware-of-foreign-keys">Beware of Foreign Keys</a></span></dt><dt><span class="section"><a href="database.html#database.implementing-your-own-datasetsdatatables">Implementing your own DataSets/DataTables</a></span></dt></dl></dd><dt><span class="section"><a href="database.html#database.the-connection-api">Using the Database Connection API</a></span></dt><dt><span class="section"><a href="database.html#database.database-assertions-api">Database Assertions API</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.asserting-the-row-count-of-a-table">Asserting the Row-Count of a Table</a></span></dt><dt><span class="section"><a href="database.html#database.asserting-the-state-of-a-table">Asserting the State of a Table</a></span></dt><dt><span class="section"><a href="database.html#database.asserting-the-result-of-a-query">Asserting the Result of a Query</a></span></dt><dt><span class="section"><a href="database.html#database.asserting-the-state-of-multiple-tables">Asserting the State of Multiple Tables</a></span></dt></dl></dd><dt><span class="section"><a href="database.html#database.frequently-asked-questions">Frequently Asked Questions</a></span></dt><dd><dl><dt><span class="section"><a href="database.html#database.will-phpunit-re-create-the-database-schema-for-each-test">Will PHPUnit (re-)create the database schema for each
             test?</a></span></dt><dt><span class="section"><a href="database.html#database.am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work">Am I required to use PDO in my application for the Database
             Extension to work?</a></span></dt><dt><span class="section"><a href="database.html#database.what-can-i-do-when-i-get-a-too-much-connections-error">What can I do, when I get a
             <span class="quote">“<span class="quote">Too much Connections</span>”</span> Error?</a></span></dt><dt><span class="section"><a href="database.html#database.how-to-handle-null-with-flat-xml-csv-datasets">How to handle NULL with Flat XML / CSV Datasets?</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="test-doubles.html">9. Test Doubles</a></span></dt><dd><dl><dt><span class="section"><a href="test-doubles.html#test-doubles.stubs">Stubs</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.mock-objects">Mock Objects</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.prophecy">Prophecy</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.mocking-traits-and-abstract-classes">Mocking Traits and Abstract Classes</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.stubbing-and-mocking-web-services">Stubbing and Mocking Web Services</a></span></dt><dt><span class="section"><a href="test-doubles.html#test-doubles.mocking-the-filesystem">Mocking the Filesystem</a></span></dt></dl></dd><dt><span class="chapter"><a href="testing-practices.html">10. Testing Practices</a></span></dt><dd><dl><dt><span class="section"><a href="testing-practices.html#testing-practices.during-development">During Development</a></span></dt><dt><span class="section"><a href="testing-practices.html#testing-practices.during-debugging">During Debugging</a></span></dt></dl></dd><dt><span class="chapter"><a href="code-coverage-analysis.html">11. Code Coverage Analysis</a></span></dt><dd><dl><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.metrics">Software Metrics for Code Coverage</a></span></dt><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.whitelisting-files">Whitelisting Files</a></span></dt><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.ignoring-code-blocks">Ignoring Code Blocks</a></span></dt><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.specifying-covered-methods">Specifying Covered Methods</a></span></dt><dt><span class="section"><a href="code-coverage-analysis.html#code-coverage-analysis.edge-cases">Edge Cases</a></span></dt></dl></dd><dt><span class="chapter"><a href="other-uses-for-tests.html">12. Other Uses for Tests</a></span></dt><dd><dl><dt><span class="section"><a href="other-uses-for-tests.html#other-uses-for-tests.agile-documentation">Agile Documentation</a></span></dt><dt><span class="section"><a href="other-uses-for-tests.html#other-uses-for-tests.cross-team-tests">Cross-Team Tests</a></span></dt></dl></dd><dt><span class="chapter"><a href="logging.html">13. Logging</a></span></dt><dd><dl><dt><span class="section"><a href="logging.html#logging.xml">Test Results (XML)</a></span></dt><dt><span class="section"><a href="logging.html#logging.codecoverage.xml">Code Coverage (XML)</a></span></dt><dt><span class="section"><a href="logging.html#logging.codecoverage.text">Code Coverage (TEXT)</a></span></dt></dl></dd><dt><span class="chapter"><a href="extending-phpunit.html">14. Extending PHPUnit</a></span></dt><dd><dl><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.PHPUnit_Framework_TestCase">Subclass PHPUnit\Framework\TestCase</a></span></dt><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.custom-assertions">Write custom assertions</a></span></dt><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.PHPUnit_Framework_TestListener">Implement PHPUnit\Framework\TestListener</a></span></dt><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.PHPUnit_Extensions_TestDecorator">Subclass PHPUnit_Extensions_TestDecorator</a></span></dt><dt><span class="section"><a href="extending-phpunit.html#extending-phpunit.PHPUnit_Framework_Test">Implement PHPUnit_Framework_Test</a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.assertions.html">A. Assertions</a></span></dt><dd><dl><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.static-vs-non-static-usage-of-assertion-methods">Static vs. Non-Static Usage of Assertion Methods</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertArrayHasKey">assertArrayHasKey()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertClassHasAttribute">assertClassHasAttribute()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertArraySubset">assertArraySubset()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertClassHasStaticAttribute">assertClassHasStaticAttribute()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertContains">assertContains()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertContainsOnly">assertContainsOnly()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertContainsOnlyInstancesOf">assertContainsOnlyInstancesOf()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertCount">assertCount()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertDirectoryExists">assertDirectoryExists()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertDirectoryIsReadable">assertDirectoryIsReadable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertDirectoryIsWritable">assertDirectoryIsWritable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertEmpty">assertEmpty()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertEqualXMLStructure">assertEqualXMLStructure()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertEquals">assertEquals()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFalse">assertFalse()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFileEquals">assertFileEquals()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFileExists">assertFileExists()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFileIsReadable">assertFileIsReadable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertFileIsWritable">assertFileIsWritable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertGreaterThan">assertGreaterThan()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertGreaterThanOrEqual">assertGreaterThanOrEqual()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertInfinite">assertInfinite()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertInstanceOf">assertInstanceOf()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertInternalType">assertInternalType()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertIsReadable">assertIsReadable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertIsWritable">assertIsWritable()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertJsonFileEqualsJsonFile">assertJsonFileEqualsJsonFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertJsonStringEqualsJsonFile">assertJsonStringEqualsJsonFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertJsonStringEqualsJsonString">assertJsonStringEqualsJsonString()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertLessThan">assertLessThan()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertLessThanOrEqual">assertLessThanOrEqual()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertNan">assertNan()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertNull">assertNull()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertObjectHasAttribute">assertObjectHasAttribute()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertRegExp">assertRegExp()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringMatchesFormat">assertStringMatchesFormat()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringMatchesFormatFile">assertStringMatchesFormatFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertSame">assertSame()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringEndsWith">assertStringEndsWith()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringEqualsFile">assertStringEqualsFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertStringStartsWith">assertStringStartsWith()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertThat">assertThat()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertTrue">assertTrue()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertXmlFileEqualsXmlFile">assertXmlFileEqualsXmlFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertXmlStringEqualsXmlFile">assertXmlStringEqualsXmlFile()</a></span></dt><dt><span class="section"><a href="appendixes.assertions.html#appendixes.assertions.assertXmlStringEqualsXmlString">assertXmlStringEqualsXmlString()</a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.annotations.html">B. Annotations</a></span></dt><dd><dl><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.author">@author</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.after">@after</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.afterClass">@afterClass</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.backupGlobals">@backupGlobals</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.backupStaticAttributes">@backupStaticAttributes</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.before">@before</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.beforeClass">@beforeClass</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.codeCoverageIgnore">@codeCoverageIgnore*</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.covers">@covers</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.coversDefaultClass">@coversDefaultClass</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.coversNothing">@coversNothing</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.dataProvider">@dataProvider</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.depends">@depends</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.doesNotPerformAssertions">@doesNotPerformAssertions</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.expectedException">@expectedException</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.expectedExceptionCode">@expectedExceptionCode</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.expectedExceptionMessage">@expectedExceptionMessage</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.expectedExceptionMessageRegExp">@expectedExceptionMessageRegExp</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.group">@group</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.large">@large</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.medium">@medium</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.preserveGlobalState">@preserveGlobalState</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.requires">@requires</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.runTestsInSeparateProcesses">@runTestsInSeparateProcesses</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.runInSeparateProcess">@runInSeparateProcess</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.small">@small</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.test">@test</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.testdox">@testdox</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.testWith">@testWith</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.ticket">@ticket</a></span></dt><dt><span class="section"><a href="appendixes.annotations.html#appendixes.annotations.uses">@uses</a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.configuration.html">C. The XML Configuration File</a></span></dt><dd><dl><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.phpunit">PHPUnit</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.testsuites">Test Suites</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.groups">Groups</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.whitelisting-files">Whitelisting Files for Code Coverage</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.logging">Logging</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.test-listeners">Test Listeners</a></span></dt><dt><span class="section"><a href="appendixes.configuration.html#appendixes.configuration.php-ini-constants-variables">Setting PHP INI settings, Constants and Global Variables</a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.index.html">D. Index</a></span></dt><dd><dl><dt><span class="index"><a href="appendixes.index.html#appendixes.index.index"></a></span></dt></dl></dd><dt><span class="appendix"><a href="appendixes.bibliography.html">E. Bibliography</a></span></dt><dt><span class="appendix"><a href="appendixes.copyright.html">F. Copyright</a></span></dt></dl>
     </div>
    </div>
    <div class="col-md-8 col-lg-9">
     <div class="row">
      <div class="col-md-1 pull-left prev-nav"><a accesskey="p" href="incomplete-and-skipped-tests.html">Prev</a></div>
      <div class="col-md-1 pull-right next-nav"><a accesskey="n" href="test-doubles.html">Next</a></div>
     </div>
<div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="database"></a>Chapter 8. Database Testing</h1></div></div></div><p>
    Many beginner and intermediate unit testing examples in any programming
    language suggest that it is perfectly easy to test your application's logic with
    simple tests. For database-centric applications this is far away from the
    reality. Start using WordPress, TYPO3 or Symfony with Doctrine or Propel,
    for example, and you will easily experience considerable problems with
    PHPUnit: just because the database is so tightly coupled to these libraries.
  </p><div class="alert alert-info"><h3 class="title">Note</h3><p>
      Make sure you have the PHP extension <code class="literal">pdo</code> and database
      specific extensions such as <code class="literal">pdo_mysql</code> installed.
      Otherwise the examples shown below will not work.
    </p></div><p>
    You probably know this scenario from your daily work and projects,
    where you want to put your fresh or experienced PHPUnit skills to
    work and get stuck by one of the following problems:
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        The method you want to test executes a rather large JOIN operation and
        uses the data to calculate some important results.
      </p></li><li class="listitem"><p>
        Your business logic performs a mix of SELECT, INSERT, UPDATE and
        DELETE statements.
      </p></li><li class="listitem"><p>
        You need to setup test data in (possibly much) more than two tables
        to get reasonable initial data for the methods you want to test.
      </p></li></ol></div><p>
    The DbUnit extension considerably simplifies the setup of a database for
    testing purposes and allows you to verify the contents of a database after
    performing a series of operations.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.supported-vendors-for-database-testing"></a>Supported Vendors for Database Testing</h2></div></div></div><p>
      DbUnit currently supports MySQL, PostgreSQL, Oracle and SQLite. Through
      <a class="ulink" href="http://framework.zend.com" target="_top">Zend Framework</a> or
      <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2</a>
      integrations it has access to other database systems such as IBM DB2 or
      Microsoft SQL Server.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.difficulties-in-database-testing"></a>Difficulties in Database Testing</h2></div></div></div><p>
      There is a good reason why all the examples on unit testing do not include
      interactions with the database: these kind of tests are both complex to
      setup and maintain. While testing against your database you need to take
      care of the following variables:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          The database schema and tables
        </p></li><li class="listitem"><p>
          Inserting the rows required for the test into these tables
        </p></li><li class="listitem"><p>
          Verifying the state of the database after your test has run
        </p></li><li class="listitem"><p>
          Cleanup the database for each new test
        </p></li></ul></div><p>
      Because many database APIs such as PDO, MySQLi or OCI8 are cumbersome to
      use and verbose in writing doing these steps manually is an absolute
      nightmare.
    </p><p>
      Test code should be as short and precise as possible for several reasons:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          You do not want to modify considerable amount of test code for little
          changes in your production code.
        </p></li><li class="listitem"><p>
          You want to be able to read and understand the test code easily,
          even months after writing it.
        </p></li></ul></div><p>
      Additionally you have to realize that the database is essentially a
      global input variable to your code. Two tests in your test suite
      could run against the same database, possibly reusing data multiple
      times. Failures in one test can easily affect the result of the
      following tests making your testing experience very difficult. The
      previously mentioned cleanup step is of major importance
      to solve the <span class="quote">“<span class="quote">database is a global input</span>”</span> problem.
    </p><p>
      DbUnit helps to simplify all these problems with database testing in an
      elegant way.
    </p><p>
      What PHPUnit cannot help you with is the fact that database tests
      are very slow compared to tests not using the database. Depending
      on how large the interactions with your database are your tests
      could run a considerable amount of time. However, if you keep the amount of
      data used for each test small and try to test as much code using
      non-database tests you can easily get away in under a minute even
      for large test suites.
    </p><p>
      The <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2
      project</a>'s test suite, for example, currently has a test suite of
      about 1000 tests where nearly half of them accesses the database
      and still runs in 15 seconds against a MySQL database on a standard
      desktop computer.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.the-four-stages-of-a-database-test"></a>The four stages of a database test</h2></div></div></div><p>
      In his book on xUnit Test Patterns Gerard Meszaros lists the four
      stages of a unit-test:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          Set up fixture
        </p></li><li class="listitem"><p>
          Exercise System Under Test
        </p></li><li class="listitem"><p>
          Verify outcome
        </p></li><li class="listitem"><p>
          Teardown
        </p></li></ol></div><div class="blockquote"><blockquote class="blockquote"><p>
        <span class="strong"><strong>What is a Fixture?</strong></span>
      </p><p>
        A fixture describes the initial state your application and database
        are in when you execute a test.
      </p></blockquote></div><p>
      Testing the database requires you to hook into at least the
      setup and teardown to clean-up and write the required fixture data
      into your tables. However, the database extension has good reason to
      revert the four stages in a database test to resemble the following
      workflow that is executed for each single test:
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.clean-up-database"></a>1. Clean-Up Database</h3></div></div></div><p>
        Since there is always a first test that runs against the database
        you do not know exactly if there is already data in the tables.
        PHPUnit will execute a TRUNCATE against all the tables you
        specified to reset their status to empty.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.set-up-fixture"></a>2. Set up fixture</h3></div></div></div><p>
        PHPUnit will then iterate over all the fixture rows specified and
        insert them into their respective tables.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.run-test-verify-outcome-and-teardown"></a>3–5. Run Test, Verify outcome and Teardown</h3></div></div></div><p>
        After the database is reset and loaded with its initial state the
        actual test is executed by PHPUnit. This part of the test code does
        not require awareness of the Database Extension at all, you can
        go on and test whatever you like with your code.
      </p><p>
        In your test use a special assertion called
        <code class="literal">assertDataSetsEqual()</code> for verification purposes,
        however, this is entirely optional. This feature will be explained
        in the section <span class="quote">“<span class="quote">Database Assertions</span>”</span>.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.configuration-of-a-phpunit-database-testcase"></a>Configuration of a PHPUnit Database TestCase</h2></div></div></div><p>
      Usually when using PHPUnit your testcases would extend the
      <code class="literal">PHPUnit\Framework\TestCase</code> class in the
      following way:
    </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    public function testCalculate()
    {
        $this-&gt;assertEquals(2, 1 + 1);
    }
}
?&gt;</pre><p>
      If you want to test code that works with the Database Extension the
      setup is a bit more complex and you have to extend a different
      abstract TestCase requiring you to implement two abstract methods
      <code class="literal">getConnection()</code> and
      <code class="literal">getDataSet()</code>:
    </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyGuestbookTest extends TestCase
{
    use TestCaseTrait;

    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $pdo = new PDO('sqlite::memory:');
        return $this-&gt;createDefaultDBConnection($pdo, ':memory:');
    }

    /**
     * @return PHPUnit_Extensions_Database_DataSet_IDataSet
     */
    public function getDataSet()
    {
        return $this-&gt;createFlatXMLDataSet(dirname(__FILE__).'/_files/guestbook-seed.xml');
    }
}
?&gt;</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.implementing-getconnection"></a>Implementing getConnection()</h3></div></div></div><p>
        To allow the clean-up and fixture loading functionalities to work
        the PHPUnit Database Extension requires access to a database
        connection abstracted across vendors through the PDO library. It
        is important to note that your application does not need to be
        based on PDO to use PHPUnit's database extension, the connection is
        merely used for the clean-up and fixture setup.
      </p><p>
        In the previous example we create an in-memory Sqlite connection
        and pass it to the <code class="literal">createDefaultDBConnection</code>
        method which wraps the PDO instance and the second parameter (the
        database-name) in a very simple abstraction layer for database
        connections of the type
        <code class="literal">PHPUnit_Extensions_Database_DB_IDatabaseConnection</code>.
      </p><p>
        The section <span class="quote">“<span class="quote">Using the Database Connection API</span>”</span> explains
        the API of this interface and how you can make the best use of it.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.implementing-getdataset"></a>Implementing getDataSet()</h3></div></div></div><p>
        The <code class="literal">getDataSet()</code> method defines how the initial
        state of the database should look before each test is
        executed. The state of a database is abstracted through the
        concepts DataSet and DataTable both being represented by the
        interfaces
        <code class="literal">PHPUnit_Extensions_Database_DataSet_IDataSet</code> and
        <code class="literal">PHPUnit_Extensions_Database_DataSet_IDataTable</code>.
        The next section will describe in detail how these concepts work
        and what the benefits are for using them in database testing.
      </p><p>
        For the implementation we only need to know that the
        <code class="literal">getDataSet()</code> method is called once during
        <code class="literal">setUp()</code> to retrieve the fixture data-set and
        insert it into the database. In the example we are using a factory
        method <code class="literal">createFlatXMLDataSet($filename)</code> that
        represents a data-set through an XML representation.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.what-about-the-database-schema-ddl"></a>What about the Database Schema (DDL)?</h3></div></div></div><p>
        PHPUnit assumes that the database schema with all its tables,
        triggers, sequences and views is created before a test is run. This
        means you as developer have to make sure that the database is
        correctly setup before running the suite.
      </p><p>
        There are several means to achieve this pre-condition to database
        testing.
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            If you are using a persistent database (not Sqlite Memory) you can
            easily setup the database once with tools such as phpMyAdmin for
            MySQL and re-use the database for every test-run.
          </p></li><li class="listitem"><p>
            If you are using libraries such as
            <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2</a> or
            <a class="ulink" href="http://www.propelorm.org/" target="_top">Propel</a>
            you can use their APIs to create the database schema you
            need once before you run the tests. You can utilize
            <a class="ulink" href="textui.html" target="_top">PHPUnit's Bootstrap and Configuration</a>
            capabilities to execute this code whenever your tests are run.
          </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.tip-use-your-own-abstract-database-testcase"></a>Tip: Use your own Abstract Database TestCase</h3></div></div></div><p>
        From the previous implementation example you can easily see that
        <code class="literal">getConnection()</code> method is pretty static and
        could be re-used in different database test-cases. Additionally to
        keep performance of your tests good and database overhead low you
        can refactor the code a little bit to get a generic abstract test
        case for your application, which still allows you to specify a
        different data-fixture for each test case:
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class MyApp_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO('sqlite::memory:');
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, ':memory:');
        }

        return $this-&gt;conn;
    }
}
?&gt;</pre><p>
        This has the database connection hardcoded in the PDO connection
        though. PHPUnit has another awesome feature that could make this
        testcase even more generic. If you use the
        <a class="ulink" href="appendixes.configuration.html#appendixes.configuration.php-ini-constants-variables" target="_top">XML Configuration</a>
        you could make the database connection configurable per test-run.
        First let's create a <span class="quote">“<span class="quote">phpunit.xml</span>”</span> file in our tests/
        directory of the application that looks like:
      </p><pre class="screen">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;phpunit&gt;
    &lt;php&gt;
        &lt;var name="DB_DSN" value="mysql:dbname=myguestbook;host=localhost" /&gt;
        &lt;var name="DB_USER" value="user" /&gt;
        &lt;var name="DB_PASSWD" value="passwd" /&gt;
        &lt;var name="DB_DBNAME" value="myguestbook" /&gt;
    &lt;/php&gt;
&lt;/phpunit&gt;
</pre><p>
        We can now modify our test-case to look like:
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class Generic_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this-&gt;conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO( $GLOBALS['DB_DSN'], $GLOBALS['DB_USER'], $GLOBALS['DB_PASSWD'] );
            }
            $this-&gt;conn = $this-&gt;createDefaultDBConnection(self::$pdo, $GLOBALS['DB_DBNAME']);
        }

        return $this-&gt;conn;
    }
}
?&gt;</pre><p>
        We can now run the database test suite using different
        configurations from the command-line interface:
      </p><pre class="screen"><strong class="userinput"><code>user@desktop&gt; phpunit --configuration developer-a.xml MyTests/</code></strong>
<strong class="userinput"><code>user@desktop&gt; phpunit --configuration developer-b.xml MyTests/</code></strong></pre><p>
        The possibility to run the database tests against different
        database targets easily is very important if you are developing on
        the development machine. If several developers run the database
        tests against the same database connection you can easily
        experience test-failures because of race-conditions.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.understanding-datasets-and-datatables"></a>Understanding DataSets and DataTables</h2></div></div></div><p>
      A central concept of PHPUnit's Database Extension are DataSets and
      DataTables. You should try to understand this simple concept to
      master database testing with PHPUnit. The DataSet and DataTable are
      an abstraction layer around your database tables, rows and
      columns. A simple API hides the underlying database contents in an
      object structure, which can also be implemented by other
      non-database sources.
    </p><p>
      This abstraction is necessary to compare the actual contents of a
      database against the expected contents. Expectations can be
      represented as XML, YAML, CSV files or PHP array for example. The
      DataSet and DataTable interfaces enable the comparison of these
      conceptually different sources, emulating relational database
      storage in a semantically similar approach.
    </p><p>
      A workflow for database assertions in your tests then consists of
      three simple steps:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Specify one or more tables in your database by table name (actual
          dataset)
        </p></li><li class="listitem"><p>
          Specify the expected dataset in your preferred format (YAML, XML,
          ..)
        </p></li><li class="listitem"><p>
          Assert that both dataset representations equal each other.
        </p></li></ul></div><p>
      Assertions are not the only use-case for the DataSet and DataTable
      in PHPUnit's Database Extension. As shown in the previous section
      they also describe the initial contents of a database. You are
      forced to define a fixture dataset by the Database TestCase, which
      is then used to:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Delete all the rows from the tables specified in the dataset.
        </p></li><li class="listitem"><p>
          Write all the rows in the data-tables into the database.
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.available-implementations"></a>Available Implementations</h3></div></div></div><p>
        There are three different types of datasets/datatables:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            File-Based DataSets and DataTables
          </p></li><li class="listitem"><p>
            Query-Based DataSet and DataTable
          </p></li><li class="listitem"><p>
            Filter and Composition DataSets and DataTables
          </p></li></ul></div><p>
        The file-based datasets and tables are generally used for the
        initial fixture and to describe the expected state of the database.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.flat-xml-dataset"></a>Flat XML DataSet</h4></div></div></div><p>
          The most common dataset is called Flat XML. It is a very simple xml
          format where a tag inside the root node
          <code class="literal">&lt;dataset&gt;</code> represents exactly one row in the
          database. The tags name equals the table to insert the row into and
          an attribute represents the column. An example for a simple guestbook
          application could look like this:
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre><p>
          This is obviously easy to write. Here
          <code class="literal">&lt;guestbook&gt;</code> is the table name where two rows
          are inserted into each with four columns <span class="quote">“<span class="quote">id</span>”</span>,
          <span class="quote">“<span class="quote">content</span>”</span>, <span class="quote">“<span class="quote">user</span>”</span> and
          <span class="quote">“<span class="quote">created</span>”</span> with their respective values.
        </p><p>
          However, this simplicity comes at a cost.
        </p><p>
          From the previous example it isn't obvious how you would specify an
          empty table. You can insert a tag with no attributes with the name
          of the empty table. A flat xml file for an empty guestbook table
          would then look like:
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook /&gt;
&lt;/dataset&gt;
</pre><p>
          The handling of NULL values with the flat xml dataset is tedious. A
          NULL value is different than an empty string value in almost any
          database (Oracle being an exception), something that is difficult
          to describe in the flat xml format. You can represent a NULL's value
          by omitting the attribute from the row specification. If our
          guestbook would allow anonymous entries represented by a NULL value
          in the user column, a hypothetical state of the guestbook table
          could look like:
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre><p>
          In this case the second entry is posted anonymously. However, this
          leads to a serious problem with column recognition. During dataset
          equality assertions each dataset has to specify what columns a
          table holds. If an attribute is NULL for all the rows of a
          data-table, how would the Database Extension know that the column
          should be part of the table?
        </p><p>
          The flat xml dataset makes a crucial assumption now, defining that
          the attributes on the first defined row of a table define the
          columns of this table. In the previous example this would mean
          <span class="quote">“<span class="quote">id</span>”</span>, <span class="quote">“<span class="quote">content</span>”</span>, <span class="quote">“<span class="quote">user</span>”</span> and
          <span class="quote">“<span class="quote">created</span>”</span> are columns of the guestbook table. For the
          second row where <span class="quote">“<span class="quote">user</span>”</span> is not defined a NULL would be
          inserted into the database.
        </p><p>
          When the first guestbook entry is deleted from the dataset only
          <span class="quote">“<span class="quote">id</span>”</span>, <span class="quote">“<span class="quote">content</span>”</span> and
          <span class="quote">“<span class="quote">created</span>”</span> would be columns of the guestbook table,
          since <span class="quote">“<span class="quote">user</span>”</span> is not specified.
        </p><p>
          To use the Flat XML dataset effectively when NULL values are
          relevant the first row of each table must not contain any NULL
          value and only successive rows are allowed to omit attributes. This
          can be awkward, since the order of the rows is a relevant factor
          for database assertions.
        </p><p>
          In turn, if you specify only a subset of the table columns in the
          Flat XML dataset all the omitted values are set to their default
          values. This will lead to errors if one of the omitted columns is
          defined as <span class="quote">“<span class="quote">NOT NULL DEFAULT NULL</span>”</span>.
        </p><p>
          In conclusion I can only advise using the Flat XML datasets if you
          do not need NULL values.
        </p><p>
          You can create a flat xml dataset instance from within your
          Database TestCase by calling the
          <code class="literal">createFlatXmlDataSet($filename)</code> method:
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.xml');
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.xml-dataset"></a>XML DataSet</h4></div></div></div><p>
          There is another more structured XML dataset, which is a bit more
          verbose to write but avoids the NULL problems of the Flat XML
          dataset. Inside the root node <code class="literal">&lt;dataset&gt;</code> you
          can specify <code class="literal">&lt;table&gt;</code>,
          <code class="literal">&lt;column&gt;</code>, <code class="literal">&lt;row&gt;</code>,
          <code class="literal">&lt;value&gt;</code> and
          <code class="literal">&lt;null /&gt;</code> tags. An equivalent dataset to the
          previously defined Guestbook Flat XML looks like:
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;table name="guestbook"&gt;
        &lt;column&gt;id&lt;/column&gt;
        &lt;column&gt;content&lt;/column&gt;
        &lt;column&gt;user&lt;/column&gt;
        &lt;column&gt;created&lt;/column&gt;
        &lt;row&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;value&gt;Hello buddy!&lt;/value&gt;
            &lt;value&gt;joe&lt;/value&gt;
            &lt;value&gt;2010-04-24 17:15:23&lt;/value&gt;
        &lt;/row&gt;
        &lt;row&gt;
            &lt;value&gt;2&lt;/value&gt;
            &lt;value&gt;I like it!&lt;/value&gt;
            &lt;null /&gt;
            &lt;value&gt;2010-04-26 12:14:20&lt;/value&gt;
        &lt;/row&gt;
    &lt;/table&gt;
&lt;/dataset&gt;
</pre><p>
          Any defined <code class="literal">&lt;table&gt;</code> has a name and requires
          a definition of all the columns with their names. It can contain zero
          or any positive number of nested <code class="literal">&lt;row&gt;</code>
          elements. Defining no <code class="literal">&lt;row&gt;</code> element means
          the table is empty. The <code class="literal">&lt;value&gt;</code> and
          <code class="literal">&lt;null /&gt;</code> tags have to be specified in the
          order of the previously given <code class="literal">&lt;column&gt;</code>
          elements. The <code class="literal">&lt;null /&gt;</code> tag obviously means
          that the value is NULL.
        </p><p>
          You can create a xml dataset instance from within your
          Database TestCase by calling the
          <code class="literal">createXmlDataSet($filename)</code> method:
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this-&gt;createXMLDataSet('myXmlFixture.xml');
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.mysql-xml-dataset"></a>MySQL XML DataSet</h4></div></div></div><p>
          This new XML format is specific to the
          <a class="ulink" href="http://www.mysql.com" target="_top">MySQL database server</a>.
          Support for it was added in PHPUnit 3.5. Files in this format can
          be generated using the
          <a class="ulink" href="http://dev.mysql.com/doc/refman/5.0/en/mysqldump.html" target="_top"><code class="literal">mysqldump</code></a>
          utility. Unlike CSV datasets, which <code class="literal">mysqldump</code>
          also supports, a single file in this XML format can contain data
          for multiple tables. You can create a file in this format by
          invoking <code class="literal">mysqldump</code> like so:
        </p><pre class="screen"><strong class="userinput"><code>mysqldump --xml -t -u [username] --password=[password] [database] &gt; /path/to/file.xml</code></strong></pre><p>
          This file can be used in your Database TestCase by calling the
          <code class="literal">createMySQLXMLDataSet($filename)</code> method:
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this-&gt;createMySQLXMLDataSet('/path/to/file.xml');
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.yaml-dataset"></a>YAML DataSet</h4></div></div></div><p>
          Alternatively, you can use YAML dataset for the guestbook example:
        </p><pre class="screen">
guestbook:
  -
    id: 1
    content: "Hello buddy!"
    user: "joe"
    created: 2010-04-24 17:15:23
  -
    id: 2
    content: "I like it!"
    user:
    created: 2010-04-26 12:14:20
</pre><p>
          This is simple, convient AND it solves the NULL issue that the
          similar Flat XML dataset has. A NULL in YAML is just the column
          name without no value specified. An empty string is specified as
          <code class="literal">column1: ""</code>.
        </p><p>
          The YAML Dataset has no factory method on the Database TestCase
          currently, so you have to instantiate it manually:
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\YamlDataSet;

class YamlGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        return new YamlDataSet(dirname(__FILE__)."/_files/guestbook.yml");
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.csv-dataset"></a>CSV DataSet</h4></div></div></div><p>
          Another file-based dataset is based on CSV files. Each table of the
          dataset is represented as a single CSV file. For our guestbook
          example we would define a guestbook-table.csv file:
        </p><pre class="screen">
id,content,user,created
1,"Hello buddy!","joe","2010-04-24 17:15:23"
2,"I like it!","nancy","2010-04-26 12:14:20"
</pre><p>
          While this is very convenient for editing with Excel or OpenOffice,
          you cannot specify NULL values with the CSV dataset. An empty
          column will lead to the database default empty value being inserted
          into the column.
        </p><p>
          You can create a CSV DataSet by calling:
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\CsvDataSet;

class CsvGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        $dataSet = new CsvDataSet();
        $dataSet-&gt;addTable('guestbook', dirname(__FILE__)."/_files/guestbook.csv");
        return $dataSet;
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.array-dataset"></a>Array DataSet</h4></div></div></div><p>
          There is no Array based DataSet in PHPUnit's Database Extension
          (yet), but we can implement our own easily. Our guestbook example
          should look like:
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ArrayGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        return new MyApp_DbUnit_ArrayDataSet(
            [
                'guestbook' =&gt; [
                    [
                        'id' =&gt; 1,
                        'content' =&gt; 'Hello buddy!',
                        'user' =&gt; 'joe',
                        'created' =&gt; '2010-04-24 17:15:23'
                    ],
                    [
                        'id' =&gt; 2,
                        'content' =&gt; 'I like it!',
                        'user' =&gt; null,
                        'created' =&gt; '2010-04-26 12:14:20'
                    ],
                ],
            ]
        );
    }
}
?&gt;</pre><p>
          A PHP DataSet has obvious advantages over all the other file-based
          datasets:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              PHP Arrays can obviously handle <code class="literal">NULL</code> values.
            </p></li><li class="listitem"><p>
              You won't need additional files for assertions and can specify them
              directly in the TestCase.
            </p></li></ul></div><p>
          For this dataset like the Flat XML, CSV and YAML DataSets the keys
          of the first specified row define the table's column names, in the
          previous case this would be <span class="quote">“<span class="quote">id</span>”</span>,
          <span class="quote">“<span class="quote">content</span>”</span>, <span class="quote">“<span class="quote">user</span>”</span> and
          <span class="quote">“<span class="quote">created</span>”</span>.
        </p><p>
          The implementation for this Array DataSet is simple and
          straightforward:
        </p><pre class="programlisting">&lt;?php
class MyApp_DbUnit_ArrayDataSet extends PHPUnit_Extensions_Database_DataSet_AbstractDataSet
{
    /**
     * @var array
     */
    protected $tables = [];

    /**
     * @param array $data
     */
    public function __construct(array $data)
    {
        foreach ($data AS $tableName =&gt; $rows) {
            $columns = [];
            if (isset($rows[0])) {
                $columns = array_keys($rows[0]);
            }

            $metaData = new PHPUnit_Extensions_Database_DataSet_DefaultTableMetaData($tableName, $columns);
            $table = new PHPUnit_Extensions_Database_DataSet_DefaultTable($metaData);

            foreach ($rows AS $row) {
                $table-&gt;addRow($row);
            }
            $this-&gt;tables[$tableName] = $table;
        }
    }

    protected function createIterator($reverse = false)
    {
        return new PHPUnit_Extensions_Database_DataSet_DefaultTableIterator($this-&gt;tables, $reverse);
    }

    public function getTable($tableName)
    {
        if (!isset($this-&gt;tables[$tableName])) {
            throw new InvalidArgumentException("$tableName is not a table in the current database.");
        }

        return $this-&gt;tables[$tableName];
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.query-sql-dataset"></a>Query (SQL) DataSet</h4></div></div></div><p>
          For database assertions you do not only need the file-based datasets
          but also a Query/SQL based Dataset that contains the actual
          contents of the database. This is where the Query DataSet shines:
        </p><pre class="programlisting">&lt;?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook');
?&gt;</pre><p>
          Adding a table just by name is an implicit way to define the
          data-table with the following query:
        </p><pre class="programlisting">&lt;?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT * FROM guestbook');
?&gt;</pre><p>
          You can make use of this by specifying arbitrary queries for your
          tables, for example restricting rows, column or adding
          <code class="literal">ORDER BY</code> clauses:
        </p><pre class="programlisting">&lt;?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this-&gt;getConnection());
$ds-&gt;addTable('guestbook', 'SELECT id, content FROM guestbook ORDER BY created DESC');
?&gt;</pre><p>
          The section on Database Assertions will show some more details on
          how to make use of the Query DataSet.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.database-db-dataset"></a>Database (DB) Dataset</h4></div></div></div><p>
          Accessing the Test Connection you can automatically create a
          DataSet that consists of all the tables with their content in the
          database specified as second parameter to the Connections Factory
          method.
        </p><p>
          You can either create a dataset for the complete database as shown
          in <code class="literal">testGuestbook()</code>, or restrict it to a set of
          specified table names with a whitelist as shown in
          <code class="literal">testFilteredGuestbook()</code> method.
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MySqlGuestbookTest extends TestCase
{
    use TestCaseTrait;

    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $database = 'my_database';
        $user = 'my_user';
        $password = 'my_password';
        $pdo = new PDO('mysql:...', $user, $password);
        return $this-&gt;createDefaultDBConnection($pdo, $database);
    }

    public function testGuestbook()
    {
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();
        // ...
    }

    public function testFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet($tableNames);
        // ...
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.replacement-dataset"></a>Replacement DataSet</h4></div></div></div><p>
          I have been talking about NULL problems with the Flat XML and CSV
          DataSet, but there is a slightly complicated workaround to get both
          types of datasets working with NULLs.
        </p><p>
          The Replacement DataSet is a decorator for an existing dataset and
          allows you to replace values in any column of the dataset by another
          replacement value. To get our guestbook example working with NULL
          values we specify the file like:
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre><p>
          We then wrap the Flat XML DataSet into a Replacement DataSet:
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ReplacementTest extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        $ds = $this-&gt;createFlatXmlDataSet('myFlatXmlFixture.xml');
        $rds = new PHPUnit_Extensions_Database_DataSet_ReplacementDataSet($ds);
        $rds-&gt;addFullReplacement('##NULL##', null);
        return $rds;
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.dataset-filter"></a>DataSet Filter</h4></div></div></div><p>
          If you have a large fixture file you can use the DataSet Filter for
          white- and blacklisting of tables and columns that should be
          contained in a sub-dataset. This is especially handy in combination
          with the DB DataSet to filter the columns of the datasets.
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetFilterTest extends TestCase
{
    use TestCaseTrait;

    public function testIncludeFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addIncludeTables(['guestbook']);
        $filterDataSet-&gt;setIncludeColumnsForTable('guestbook', ['id', 'content']);
        // ..
    }

    public function testExcludeFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet-&gt;addExcludeTables(['foo', 'bar', 'baz']); // only keep the guestbook table!
        $filterDataSet-&gt;setExcludeColumnsForTable('guestbook', ['user', 'created']);
        // ..
    }
}
?&gt;</pre><div class="blockquote"><blockquote class="blockquote"><p>
            <span class="strong"><strong>NOTE</strong></span> You cannot use both exclude
            and include column filtering on the same table, only on different
            ones. Plus it is only possible to either white- or blacklist
            tables, not both of them.
          </p></blockquote></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="database.composite-dataset"></a>Composite DataSet</h4></div></div></div><p>
          The composite DataSet is very useful for aggregating several
          already existing datasets into a single dataset. When several
          datasets contain the same table the rows are appended in the
          specified order. For example if we have two datasets
          <span class="emphasis"><em>fixture1.xml</em></span>:
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
&lt;/dataset&gt;
</pre><p>
          and <span class="emphasis"><em>fixture2.xml</em></span>:
        </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" /&gt;
&lt;/dataset&gt;
</pre><p>
          Using the Composite DataSet we can aggregate both fixture files:
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class CompositeTest extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        $ds1 = $this-&gt;createFlatXmlDataSet('fixture1.xml');
        $ds2 = $this-&gt;createFlatXmlDataSet('fixture2.xml');

        $compositeDs = new PHPUnit_Extensions_Database_DataSet_CompositeDataSet();
        $compositeDs-&gt;addDataSet($ds1);
        $compositeDs-&gt;addDataSet($ds2);

        return $compositeDs;
    }
}
?&gt;</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.beware-of-foreign-keys"></a>Beware of Foreign Keys</h3></div></div></div><p>
        During Fixture SetUp PHPUnit's Database Extension inserts the rows
        into the database in the order they are specified in your fixture.
        If your database schema uses foreign keys this means you have to
        specify the tables in an order that does not cause foreign key
        constraints to fail.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.implementing-your-own-datasetsdatatables"></a>Implementing your own DataSets/DataTables</h3></div></div></div><p>
        To understand the internals of DataSets and DataTables, lets have a
        look at the interface of a DataSet. You can skip this part if you
        do not plan to implement your own DataSet or DataTable.
      </p><pre class="programlisting">&lt;?php
interface PHPUnit_Extensions_Database_DataSet_IDataSet extends IteratorAggregate
{
    public function getTableNames();
    public function getTableMetaData($tableName);
    public function getTable($tableName);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_IDataSet $other);

    public function getReverseIterator();
}
?&gt;</pre><p>
        The public interface is used internally by the
        <code class="literal">assertDataSetsEqual()</code> assertion on the Database
        TestCase to check for dataset quality. From the
        <code class="literal">IteratorAggregate</code> interface the IDataSet
        inherits the <code class="literal">getIterator()</code> method to iterate
        over all tables of the dataset. The reverse iterator allows PHPUnit to
        truncate tables opposite the order they were created to satisfy foreign
        key constraints.
      </p><p>
        Depending on the implementation different approaches are taken to
        add table instances to a dataset. For example, tables are added
        internally during construction from the source file in all
        file-based datasets such as <code class="literal">YamlDataSet</code>,
        <code class="literal">XmlDataSet</code> or <code class="literal">FlatXmlDataSet</code>.
      </p><p>
        A table is also represented by the following interface:
      </p><pre class="programlisting">&lt;?php
interface PHPUnit_Extensions_Database_DataSet_ITable
{
    public function getTableMetaData();
    public function getRowCount();
    public function getValue($row, $column);
    public function getRow($row);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_ITable $other);
}
?&gt;</pre><p>
        Except the <code class="literal">getTableMetaData()</code> method it is
        pretty self-explainatory. The used methods are all required for
        the different assertions of the Database Extension that are
        explained in the next chapter. The
        <code class="literal">getTableMetaData()</code> method has to return an
        implementation of the
        <code class="literal">PHPUnit_Extensions_Database_DataSet_ITableMetaData</code>
        interface, which describes the structure of the table. It holds
        information on:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            The table name
          </p></li><li class="listitem"><p>
            An array of column-names of the table, ordered by their appearance
            in the result-set.
          </p></li><li class="listitem"><p>
            An array of the primary-key columns.
          </p></li></ul></div><p>
        This interface also has an assertion that checks if two instances
        of Table Metadata equal each other, which is used by the data-set
        equality assertion.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.the-connection-api"></a>Using the Database Connection API</h2></div></div></div><p>
      There are three interesting methods on the Connection interface
      which has to be returned from the
      <code class="literal">getConnection()</code> method on the Database TestCase:
    </p><pre class="programlisting">&lt;?php
interface PHPUnit_Extensions_Database_DB_IDatabaseConnection
{
    public function createDataSet(Array $tableNames = NULL);
    public function createQueryTable($resultName, $sql);
    public function getRowCount($tableName, $whereClause = NULL);

    // ...
}
?&gt;</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          The <code class="literal">createDataSet()</code> method creates a Database
          (DB) DataSet as described in the DataSet implementations section.
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateDataSet()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet();
    }
}
?&gt;</pre></li><li class="listitem"><p>
          The <code class="literal">createQueryTable()</code> method can be used to
          create instances of a QueryTable, give them a result name and SQL
          query. This is a handy method when it comes to result/table
          assertions as will be shown in the next section on the Database
          Assertions API.
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateQueryTable()
    {
        $tableNames = ['guestbook'];
        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable('guestbook', 'SELECT * FROM guestbook');
    }
}
?&gt;</pre></li><li class="listitem"><p>
          The <code class="literal">getRowCount()</code> method is a convienent way to
          access the number of rows in a table, optionally filtered by an
          additional where clause. This can be used with a simple equality
          assertion:
        </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testGetRowCount()
    {
        $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('guestbook'));
    }
}
?&gt;</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.database-assertions-api"></a>Database Assertions API</h2></div></div></div><p>
      For a testing tool the Database Extension surely provides some
      assertions that you can use to verify the current state of the
      database, tables and the row-count of tables. This section
      describes this functionality in detail:
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.asserting-the-row-count-of-a-table"></a>Asserting the Row-Count of a Table</h3></div></div></div><p>
        It is often helpful to check if a table contains a specific amount
        of rows. You can easily achieve this without additional glue code
        using the Connection API. Say we wanted to check that after
        insertion of a row into our guestbook we not only have the two
        initial entries that have accompanied us in all the previous
        examples, but a third one:
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class GuestbookTest extends TestCase
{
    use TestCaseTrait;

    public function testAddEntry()
    {
        $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), "Pre-Condition");

        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry("suzy", "Hello world!");

        $this-&gt;assertEquals(3, $this-&gt;getConnection()-&gt;getRowCount('guestbook'), "Inserting failed");
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.asserting-the-state-of-a-table"></a>Asserting the State of a Table</h3></div></div></div><p>
        The previous assertion is helpful, but we surely want to check the
        actual contents of the table to verify that all the values were
        written into the correct columns. This can be achieved by a table
        assertion.
      </p><p>
        For this we would define a Query Table instance which derives its
        content from a table name and SQL query and compare it to a
        File/Array Based Data Set:
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class GuestbookTest extends TestCase
{
    use TestCaseTrait;

    public function testAddEntry()
    {
        $guestbook = new Guestbook();
        $guestbook-&gt;addEntry("suzy", "Hello world!");

        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'guestbook', 'SELECT * FROM guestbook'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet("expectedBook.xml")
                              -&gt;getTable("guestbook");
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
?&gt;</pre><p>
        Now we have to write the <span class="emphasis"><em>expectedBook.xml</em></span> Flat
        XML file for this assertion:
      </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" /&gt;
    &lt;guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" /&gt;
    &lt;guestbook id="3" content="Hello world!" user="suzy" created="2010-05-01 21:47:08" /&gt;
&lt;/dataset&gt;
</pre><p>
        This assertion would only pass on exactly one second of the
        universe though, on <span class="emphasis"><em>2010–05–01 21:47:08</em></span>. Dates
        pose a special problem to database testing and we can circumvent
        the failure by omitting the <span class="quote">“<span class="quote">created</span>”</span> column from the
        assertion.
      </p><p>
        The adjusted <span class="emphasis"><em>expectedBook.xml</em></span> Flat XML file
        would probably have to look like the following to make the
        assertion pass:
      </p><pre class="screen">
&lt;?xml version="1.0" ?&gt;
&lt;dataset&gt;
    &lt;guestbook id="1" content="Hello buddy!" user="joe" /&gt;
    &lt;guestbook id="2" content="I like it!" user="nancy" /&gt;
    &lt;guestbook id="3" content="Hello world!" user="suzy" /&gt;
&lt;/dataset&gt;
</pre><p>
        We have to fix up the Query Table call:
      </p><pre class="programlisting">&lt;?php
$queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
    'guestbook', 'SELECT id, content, user FROM guestbook'
);
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.asserting-the-result-of-a-query"></a>Asserting the Result of a Query</h3></div></div></div><p>
        You can also assert the result of complex queries with the Query
        Table approach, just specify a result name with a query and
        compare it to a dataset:
      </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ComplexQueryTest extends TestCase
{
    use TestCaseTrait;

    public function testComplexQuery()
    {
        $queryTable = $this-&gt;getConnection()-&gt;createQueryTable(
            'myComplexQuery', 'SELECT complexQuery...'
        );
        $expectedTable = $this-&gt;createFlatXmlDataSet("complexQueryAssertion.xml")
                              -&gt;getTable("myComplexQuery");
        $this-&gt;assertTablesEqual($expectedTable, $queryTable);
    }
}
?&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.asserting-the-state-of-multiple-tables"></a>Asserting the State of Multiple Tables</h3></div></div></div><p>
        For sure you can assert the state of multiple tables at once and
        compare a query dataset against a file based dataset. There are two
        different ways for DataSet assertions.
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            You can use the Database (DB) DataSet from the Connection and
            compare it to a File-Based DataSet.
          </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetAssertionsTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateDataSetAssertion()
    {
        $dataSet = $this-&gt;getConnection()-&gt;createDataSet(['guestbook']);
        $expectedDataSet = $this-&gt;createFlatXmlDataSet('guestbook.xml');
        $this-&gt;assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?&gt;</pre></li><li class="listitem"><p>
            You can construct the DataSet on your own:
          </p><pre class="programlisting">&lt;?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetAssertionsTest extends TestCase
{
    use TestCaseTrait;

    public function testManualDataSetAssertion()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_QueryDataSet();
        $dataSet-&gt;addTable('guestbook', 'SELECT id, content, user FROM guestbook'); // additional tables
        $expectedDataSet = $this-&gt;createFlatXmlDataSet('guestbook.xml');

        $this-&gt;assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?&gt;</pre></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="database.frequently-asked-questions"></a>Frequently Asked Questions</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.will-phpunit-re-create-the-database-schema-for-each-test"></a>Will PHPUnit (re-)create the database schema for each
             test?</h3></div></div></div><p>
        No, PHPUnit requires all database objects to be available when the
        suite is started. The Database, tables, sequences, triggers and
        views have to be created before you run the test suite.
      </p><p>
        <a class="ulink" href="http://www.doctrine-project.org" target="_top">Doctrine 2</a> or
        <a class="ulink" href="http://www.ezcomponents.org" target="_top">eZ Components</a> have
        powerful tools that allow you to create the database schema from
        pre-defined datastructures. However, these have to be hooked into
        the PHPUnit extension to allow an automatic database re-creation
        before the complete test-suite is run.
      </p><p>
        Since each test completely cleans the database you are not even
        required to re-create the database for each test-run. A permanently
        available database works perfectly.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work"></a>Am I required to use PDO in my application for the Database
             Extension to work?</h3></div></div></div><p>
        No, PDO is only required for the fixture clean- and set-up and for
        assertions. You can use whatever database abstraction you want
        inside your own code.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.what-can-i-do-when-i-get-a-too-much-connections-error"></a>What can I do, when I get a
             <span class="quote">“<span class="quote">Too much Connections</span>”</span> Error?</h3></div></div></div><p>
        If you do not cache the PDO instance that is created from the
        TestCase <code class="literal">getConnection()</code> method the number of
        connections to the database is increasing by one or more with each
        database test. With default configuration MySql only allows 100
        concurrent connections other vendors also have maximum connection
        limits.
      </p><p>
        The SubSection
        <span class="quote">“<span class="quote">Use your own Abstract Database TestCase</span>”</span> shows how
        you can prevent this error from happening by using a single cached
        PDO instance in all your tests.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="database.how-to-handle-null-with-flat-xml-csv-datasets"></a>How to handle NULL with Flat XML / CSV Datasets?</h3></div></div></div><p>
        Do not do this. Instead, you should use either the XML or the YAML
        DataSets.
      </p></div></div></div>
     <div class="row">
      <div class="col-md-1 pull-left prev-nav"><a accesskey="p" href="incomplete-and-skipped-tests.html">Prev</a></div>
      <div class="col-md-1 pull-right next-nav"><a accesskey="n" href="test-doubles.html">Next</a></div>
     </div>
    </div>
   </div>
   <hr/>
   <footer>
    <p><a href="appendixes.copyright.html">Copyright</a> &copy; 2005-2017 <a href="http://sebastian-bergmann.de/">Sebastian Bergmann</a>.</p>
   </footer>
  </div>
  <script src="js/jquery.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <script src="js/highlight.pack.js"></script>
  <script type="text/javascript">
  $(document).ready(function() { $('pre.programlisting').each(function(i, e) {hljs.highlightBlock(e)}); });
  </script>
 </body>
</html>
